<!-- markdownlint-disable MD013 MD034 MD033 MD038 MD051 MD040 MD036 -->

# A Generic Schema for Creating FZF Command

## Table of Contents

- [Introduction](#introduction)
- [Context](#context)
- [Provider](#provider)
- [Provider Decorator](#provider-decorator)
- [Previewer](#previewer)
- [Previewer Label](#previewer-label)
- [Command Feed](#command-feed)
- [Fzf Option](#fzf-option)
- [Interaction/Action](#interactionaction)
- [Pipeline](#pipeline)
- [Command Group](#command-group)

## Introduction

A fzf-based search command usually consists of below components:

- **Provider**: A shell command that generates the lines for (the left side of) the fzf binary.

  - (Optional) **Provider Decorator**: A lua function that modifies the generated lines. For example `FzfxFiles` prepends file type icons for each line generated by provider `fd`/`find` command.

- **Previewer**: A shell command that generates the contents to preview the current line under cursor/marker in the fzf's (right side of) preview window.

  - (Optional) **Previewer Label**: A label (string) on the top of fzf's preview window, which gives extra hint and summary.

- **Action**: A key that first quits fzf's interactive window, then invokes a registered lua function with selected lines. For example, press `ENTER` key in `FzfxFiles` will quit popup window and open all the selected files.
- (Optional) **Interaction**: A key that invokes a registered lua function but doesn't quit the fzf binary. For example, press `CTRL-U`/`CTRL-R` key in `FzfxFiles` will switch between **unrestricted mode** and **restricted mode**.
- (Optional) **Fzf Option**: Other fzf options that control the fzf binary's layout/border/etc.
- (Optional) **Other Option**: Other special options that control some specific searching behavior, for example live reloading, popup window layout, etc.

This is a [producer-consumer pattern](https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem), i.e. **Provider** is the data producer, **Previewer** and **Action**/**Interaction** are the data consumers. We also say it's a dataflow, when putting all these components together, it's named a **Pipeline** in this plugin.

With this pattern, all the details of launching the fzf shell command and interacting across different child processes within nvim editor are hidden, only a friendly config layer is provided to user and allows third-party plugin developers to create almost any searching commands on their own needs.

Let's define it more specifically.

> Also see: [schema.lua](https://github.com/linrongbin16/fzfx.nvim/blob/main/lua/fzfx/schema.lua).

## Context

A **context** is some data that passing to pipeline.

Starting a searching command is actually creating a popup window and a terminal, running a fzf shell command inside it. Thus there's no way to get the current buffer number (`bufnr`) or current window number (`winnr`) you're editing (actually it's the _previous_ buffer/window).

So we need a way to store the **_current_** buffer/window info in somewhere, so we need to create a context before creating the popup window and launching the shell command.

```lua
--- @alias fzfx.PipelineContext {bufnr:integer,winnr:integer,tabnr:integer}
--- @alias fzfx.PipelineContextMaker fun():fzfx.PipelineContext
```

## Provider

A **provider** is a shell command that runs in terminal and generates the lines for (the left side of) the fzf binary.

When fzf works inside Neovim editor, this plugin will use `nvim` as a lua interpreter and a Neovim-editor-as-a-VM runtime environment. Thus this plugin runs a `nvim --headless -l` shell command inside the terminal of the popup window, and the `nvim` command interprets a lua script to do the query for the fzf command. This design would allow us to do complicated and dynamic logic, i.e. invoking a lua function.

> Also see: [fzfx's architecture](https://github.com/linrongbin16/fzfx.nvim/wiki/How%3F).

We have below types of providers:

- Plain provider: a simple shell command (a string or a strings list), that executes and generates the lines for fzf. For example `fd`/`find` or `fd . -cnever -tf -tl -L -i`.
- Command provider: a lua function that runs and returns a shell command, then executes and generates the lines for fzf. Thus enables the dynamical ability on each query, and generates different querying results. When working with fzf's [`change` event](https://man.archlinux.org/man/fzf.1.en#AVAILABLE_EVENTS:) and [`reload` action](https://man.archlinux.org/man/fzf.1.en#RELOAD_INPUT), it achieves the **_live reloading_** while user entering the query content.
- List provider: a lua function that runs and directly returns the lines for fzf.

```lua
--- @alias fzfx.PlainProvider string|string[]
--- @alias fzfx.CommandProvider fun(query:string?,context:fzfx.PipelineContext?):string?|string[]?
--- @alias fzfx.ListProvider fun(query:string?,context:fzfx.PipelineContext?):string[]?
--- @alias fzfx.Provider fzfx.PlainProvider|fzfx.CommandProvider|fzfx.ListProvider
---
--- Note: the 1st parameter 'query' is the current input query in prompt.
---
--- @alias fzfx.ProviderType "plain"|"command"|"list"|"plain_list"|"command_list"
--- @enum fzfx.ProviderTypeEnum
local ProviderTypeEnum = {
  -- A lua string or strings list.
  PLAIN = "plain",
  PLAIN_LIST = "plain_list",
  -- A lua function, that returns a string or strings list.
  COMMAND = "command",
  COMMAND_LIST = "command_list",
  -- A lua function, that directly returns lines.
  LIST = "list",
}
```

### Provider Decorator

Sometimes we want to decorate the generated lines, for example we want to prepend a file type icon at the beginning of each file names in `FzfxFiles` command. And here we need the **provider decorator**, it's a lua function that runs with a line as parameter, and returns the decorated line.

```lua
--- @alias fzfx._FunctionProviderDecorator fun(line:string?):string?
--- @alias fzfx.ProviderDecorator {module:string,rtp:string?,builtin:boolean?}
--
-- Note: the 1st parameter `line` in `fzfx._FunctionProviderDecorator` is the raw line generated by providers.
```

In the `fzfx.ProviderDecorator`:

1. The `module` option must be a lua module that contains a `decorate(line:string?):string?` lua function.
2. Please see builtin provider decorators here: [`fzfx.helper.provider_decorators`](https://github.com/linrongbin16/fzfx.nvim/blob/main/lua/fzfx/helper/provider_decorators) package.

   1. [`prepend_icon_find.lua`](https://github.com/linrongbin16/fzfx.nvim/blob/main/lua/fzfx/helper/provider_decorators/prepend_icon_find.lua): Prepend file type icons for `fd`/`find` providers.
   2. [`prepend_icon_grep.lua`](https://github.com/linrongbin16/fzfx.nvim/blob/main/lua/fzfx/helper/provider_decorators/prepend_icon_grep.lua): Prepend file type icons for `rg`/`grep` providers.

3. The `builtin` option is optional, with `builtin=true` you can simply set `module="prepend_icon_find"` instead of `module="fzfx.helper.provider_decorators.prepend_icon_find"`. The package path `"fzfx.helper.provider_decorators"` will be added internally.
4. The default nvim config folder `:stdpath('config')` is been added to runtime path by default on loading a provider decorator, so all lua modules in your nvim config can be loaded.
5. The `rtp` option is optional, set this option if the lua module is in other places.

> Also see `provider_decorator` option in [files.lua](https://github.com/linrongbin16/fzfx.nvim/blob/main/lua/fzfx/cfg/files.lua) (the `FzfxFiles` command), and in [live_grep.lua](https://github.com/linrongbin16/fzfx.nvim/blob/main/lua/fzfx/cfg/live_grep.lua) (the `FzfxLiveGrep` command).

You may notice that, there's no 2nd parameter `context` in the `fzfx._FunctionProviderDecorator` API signature. This is a limitation of current architecture.

> A `context` only exists inside **_the Neovim editor_**, but here we actually run the provider decorator inside the lua script interpreted by the `nvim` child process inside the popup window.
>
> Due to performance reason, the decorator is not connected with its parent process, e.g. the Neovim editor. Because it will have to be invoked for each line of the query result, and making RPC requests must be a heavy load.
>
> We use a hack that expose the runtime path of the provider decorator's (the lua function) module path to the child `nvim` process, then allows it invokes the decorator.
>
> **Note:** For the `fzfx.ProviderDecorator`, please always keep in mind:
>
> 1. It's running in a child process outside of the Neovim editor.
> 2. No plugins are loaded, only standard LuaJIT and Neovim APIs are available.

## Previewer

A **previewer** is a shell command that read current line and generate the preview contents for (the right side of) the fzf binary.

We have below types of previewers:

- Command previewer: a lua function to run and returns a shell command (as a string or a string list), then execute and generate the preview contents for fzf.
- List previewer: a lua function to run and directly returns the preview contents for fzf.
- Buffer file previewer: a nvim buffer to show the file contents.

```lua
--- @alias fzfx.CommandPreviewer fun(line:string?,context:fzfx.PipelineContext?):string?
--- @alias fzfx.ListPreviewer fun(line:string?,context:fzfx.PipelineContext?):string[]?
--- @alias fzfx.BufferFilePreviewerResult {filename:string,lineno:integer?,column:integer?}
--- @alias fzfx.BufferFilePreviewer fun(line:string?,context:fzfx.PipelineContext?):fzfx.BufferFilePreviewerResult?
--- @alias fzfx.Previewer fzfx.CommandPreviewer|fzfx.ListPreviewer|fzfx.BufferFilePreviewer
---
--- @alias fzfx.PreviewerType "command"|"command_list"|"list"|"buffer_file"
--
-- Note: the 1st parameter 'line' is the current selected line in (the left side of) the fzf binary.
```

### Previewer Label

A **previewer label** is the label (title) for the preview window.

We have 2 types of previewers:

- Plain label: a static string value which is the label for the preview window.
- Function label: a lua function to run and returns the string value for the preview window.

```lua
--- @alias fzfx.PlainPreviewerLabel string
--- @alias fzfx.FunctionPreviewerLabel fun(line:string?,context:fzfx.PipelineContext?):string?
--- @alias fzfx.PreviewerLabel fzfx.PlainPreviewerLabel|fzfx.FunctionPreviewerLabel
---
--- @alias fzfx.PreviewerLabelType "plain"|"function"
--- @enum PreviewerLabelTypeEnum
local PreviewerLabelTypeEnum = {
  PLAIN = "plain",
  FUNCTION = "function",
}
--
-- Note: the 1st parameter 'line' is the current selected line.
```

## Command Feed

A **command feed** defines what to feed to the search commands, e.g. the multiple variants.

```lua
--- @alias fzfx.CommandFeed "args"|"visual"|"cword"|"put"|"resume"
```

## Fzf Option

A fzf option is directly passing to the fzf binary, e.g. `--multi`, `--bind=ctrl-e:toggle`.

We have 3 types of fzf options:

- Plain option: plain fzf option as a string, e.g. `--multi`.
- Pair option: plain fzf option as a pair of two strings, e.g. `{ '--bind', 'ctrl-e:toggle' }`.
- Function option: a lua function to run and returns above two types of fzf options.

```lua
--- @alias fzfx.PlainFzfOpt string
--- @alias fzfx.PairFzfOpt string[]
--- @alias fzfx.FunctionFzfOpt fun():fzfx.PlainFzfOpt|fzfx.PairFzfOpt
---
--- @alias fzfx.FzfOpt fzfx.PlainFzfOpt|fzfx.PairFzfOpt|fzfx.FunctionFzfOpt
```

## Interaction/Action

An (inter)action is the lua callback function binding on a key that user press and then been invoked.

We have 2 types of actions:

- Interaction: user press the key and invoke the lua function, do something on current line without quit fzf.
- Action: user press the key to quit fzf, then invoke lua function to do something on the selected lines.

```lua
--- @alias fzfx.ActionKey string
--- @alias fzfx.Interaction fun(line:string?,context:fzfx.PipelineContext):any
--- @alias fzfx.Action fun(line:string[]|nil,context:fzfx.PipelineContext):any
--
-- Note: the 1st parameter in `Interaction` is the current line.
-- Note: the 1st parameter in `Action` is the selected line(s).
```

## Pipeline

A **pipeline** binds a provider with a previewer, with an interaction to switch the data sources, and the help message.

> Note: when you only have 1 provider, the interaction key and help message can be omitted.

The **provider-interaction-previewer** is a (dataflow) pipeline.

## Command Group

The real-world command we're using, say `FzfxLiveGrep`, actually contains multiple variants:

- Basic variant: `args`, feed with command arguments.
- Visual select variant: `visual`, feed with visual selection.
- Cursor word variant: `cword`, feed with cursor word.
- Put (yank text) variant: `put`, feed with yank text.
- Resume previous search variant: `resume`, feed with previous search query content.
- And combine with other multiple data sources, e.g. restricted/unrestricted for live grep.

They're the powerful **command group**:

- It has multiple data sources from different providers, switch by different interactive keys.
- It has multiple previewers, each bind to a specific provider.
- It has multiple action keys to exit fzf and invoke lua callbacks with selected lines.
- (Optionally) It has multiple interactive keys to do something without quit fzf.
- (Optionally) It has some extra fzf options and other options for some specific abilities.
